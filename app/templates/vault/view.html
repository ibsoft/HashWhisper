{% extends 'base.html' %}
{% block title %}Secure Vault{% endblock %}

{% block content %}
<section class="vault-landing" aria-labelledby="vault-landing-title">
  <div class="container">
    <div class="vault-card card card-glass shadow-lg mx-auto">
      <div class="card-body">
        <div class="d-flex flex-column flex-md-row align-items-start justify-content-between gap-3">
          <div class="d-flex align-items-center gap-3">
            <i class="fa-solid fa-shield-halved fa-2x text-primary" aria-hidden="true"></i>
            <div>
              <h3 id="vault-landing-title" class="mb-1">{{ _('Secure vault') }}</h3>
              <p class="text-muted mb-0">
                {{ _('This link delivers a one-time secret. Open it only from trusted devices; it burns after it is read or when it expires.') }}
              </p>
            </div>
          </div>
          <span class="badge bg-primary px-3 py-2 fs-6" id="vault-status-badge">{{ _('Untouched') }}</span>
        </div>
        <div class="mt-3" id="vault-alert" role="status" aria-live="polite"></div>
        <div class="mt-4 vault-key-section">
          <label class="form-label" for="vault-key">{{ _('Secret key (the part after the # in the link)') }}</label>
          <div class="input-group">
            <input type="text" class="form-control" id="vault-key" placeholder="{{ _('Paste or scan the link and include the secret') }}">
            <button class="btn btn-soft" type="button" id="vault-auto-key">{{ _('Auto-fill from URL') }}</button>
          </div>
          <p class="text-muted small mt-2 mb-0">
            {{ _('Only the bearer of this secret key can decrypt the message. The server never stores it.') }}
          </p>
        </div>
        <div class="mt-3 d-grid gap-2">
          <button class="btn btn-primary" type="button" id="vault-decrypt-btn">{{ _('Decrypt secret') }}</button>
          <button class="btn btn-outline-secondary" type="button" id="vault-clear-btn">{{ _('Clear key and message') }}</button>
        </div>
        <div class="mt-4" id="vault-metadata" tabindex="-1" aria-live="polite"></div>
        <div class="vault-output mt-3">
          <h5 class="mb-2" id="vault-title-placeholder"></h5>
          <pre id="vault-content"></pre>
          <div class="vault-file mt-3 d-none" id="vault-file-view">
            <div class="d-flex justify-content-between align-items-start gap-3 flex-wrap">
              <div class="d-flex align-items-center gap-2">
                <i id="vault-file-type-icon" class="fa-solid fa-file fa-lg text-muted"></i>
                <div>
                  <h6 class="mb-1" id="vault-file-name"></h6>
                  <p class="text-muted small mb-0" id="vault-file-meta"></p>
                </div>
              </div>
              <a class="btn btn-sm btn-outline-light flex-shrink-0" id="vault-file-download" target="_blank" rel="noopener">{{ _('Download file') }}</a>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>

{% endblock %}

{% block scripts %}
{{ super() }}
<script>
(() => {
  const slug = "{{ slug }}";
  const statusBadge = document.getElementById('vault-status-badge');
  const alertEl = document.getElementById('vault-alert');
  const metadataEl = document.getElementById('vault-metadata');
  const titleEl = document.getElementById('vault-title-placeholder');
  const contentEl = document.getElementById('vault-content');
  const fileView = document.getElementById('vault-file-view');
  const fileIconEl = document.getElementById('vault-file-type-icon');
  const fileNameEl = document.getElementById('vault-file-name');
  const fileMetaEl = document.getElementById('vault-file-meta');
  const fileDownloadEl = document.getElementById('vault-file-download');
  const DEFAULT_FILE_LABEL = '{{ _("Secret file") }}';
  const keyInput = document.getElementById('vault-key');
  const decryptBtn = document.getElementById('vault-decrypt-btn');
  const clearBtn = document.getElementById('vault-clear-btn');
  const autoKeyBtn = document.getElementById('vault-auto-key');

  const encoder = new TextEncoder();
  const decoder = new TextDecoder();
  let entry = null;
  let currentFileUrl = null;

  function showAlert(message, variant = 'info') {
    alertEl.innerHTML = `<div class="alert alert-${variant} mb-0">${message}</div>`;
  }

  function hexToBytes(value) {
    if (!value) return new Uint8Array();
    const matches = value.match(/.{1,2}/g) || [];
    return new Uint8Array(matches.map((chunk) => parseInt(chunk, 16)));
  }

  async function deriveVaultKey(secret) {
    const material = await window.crypto.subtle.importKey('raw', encoder.encode(secret), 'PBKDF2', false, ['deriveKey']);
    return window.crypto.subtle.deriveKey(
      {
        name: 'PBKDF2',
        salt: encoder.encode('hashwhisper-vault'),
        iterations: 100000,
        hash: 'SHA-256',
      },
      material,
      { name: 'AES-GCM', length: 256 },
      false,
      ['encrypt', 'decrypt']
    );
  }

  async function decryptPayload(secret) {
    if (!entry || !secret) {
      throw new Error('{{ _("Provide the secret key to decrypt the payload.") }}');
    }
    const key = await deriveVaultKey(secret);
    const iv = hexToBytes(entry.nonce);
    const tag = hexToBytes(entry.auth_tag);
    const cipher = hexToBytes(entry.ciphertext);
    const combined = new Uint8Array(cipher.length + tag.length);
    combined.set(cipher);
    combined.set(tag, cipher.length);
    const decrypted = await window.crypto.subtle.decrypt(
      { name: 'AES-GCM', iv, additionalData: encoder.encode('HashWhisper:v1') },
      key,
      combined
    );
    return decoder.decode(decrypted);
  }

  function renderMetadata(data) {
    const expires = data.expires_at ? new Date(data.expires_at).toLocaleString() : '{{ _("Never") }}';
    const views = data.views_remaining;
    const typeLabel = data.payload_type === 'file' ? '{{ _("File secret") }}' : '{{ _("Text secret") }}';
    metadataEl.textContent = `{{ _("Expires") }}: ${expires} · {{ _("Views left") }}: ${views} · ${typeLabel}`;
    if (data.title) {
      titleEl.textContent = data.title;
    } else {
      titleEl.textContent = '{{ _("Untitled secret") }}';
    }
  }

  function formatReadableSize(bytes) {
    if (!Number.isFinite(bytes)) return '';
    if (bytes >= 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
    if (bytes >= 1024) return `${(bytes / 1024).toFixed(1)} KB`;
    return `${bytes} B`;
  }

  function getFileIconClass(mime) {
    if (!mime) return 'fa-file';
    if (mime.startsWith('image/')) return 'fa-file-image';
    if (mime.startsWith('audio/')) return 'fa-file-audio';
    if (mime.startsWith('video/')) return 'fa-file-video';
    if (mime === 'application/pdf') return 'fa-file-pdf';
    if (mime.includes('zip') || mime.includes('compressed')) return 'fa-file-zipper';
    if (mime.includes('wordprocessingml') || mime.includes('msword')) return 'fa-file-word';
    if (mime.includes('excel') || mime.includes('spreadsheetml')) return 'fa-file-excel';
    if (mime.includes('presentationml') || mime.includes('powerpoint')) return 'fa-file-powerpoint';
    if (mime.includes('json') || mime.includes('xml')) return 'fa-file-code';
    if (mime.startsWith('text/')) return 'fa-file-lines';
    return 'fa-file';
  }

  function clearFilePreview() {
    if (fileView) fileView.classList.add('d-none');
    if (currentFileUrl) {
      URL.revokeObjectURL(currentFileUrl);
      currentFileUrl = null;
    }
  }

  function base64ToBytes(value) {
    if (!value) return new Uint8Array();
    const raw = window.atob(value);
    const bytes = new Uint8Array(raw.length);
    for (let i = 0; i < raw.length; i += 1) {
      bytes[i] = raw.charCodeAt(i);
    }
    return bytes;
  }

  function prepareFileDownload(base64) {
    if (!entry || !fileView) return;
    const bytes = base64ToBytes(base64);
    const mime = entry.payload_mime || 'application/octet-stream';
    const blob = new Blob([bytes], { type: mime });
    if (currentFileUrl) {
      URL.revokeObjectURL(currentFileUrl);
    }
    currentFileUrl = URL.createObjectURL(blob);
    if (fileNameEl) {
      fileNameEl.textContent = entry.payload_name || DEFAULT_FILE_LABEL;
    }
    if (fileMetaEl) {
      fileMetaEl.textContent = `${mime} · ${formatReadableSize(entry.payload_size || bytes.length)}`;
    }
    if (fileDownloadEl) {
      fileDownloadEl.href = currentFileUrl;
      fileDownloadEl.download = entry.payload_name || 'secret-file';
    }
    if (fileIconEl) {
      const iconClass = getFileIconClass(mime);
      fileIconEl.className = `fa-solid ${iconClass} fa-lg text-muted`;
    }
    fileView.classList.remove('d-none');
  }

  function updateStatus(text, variant = 'primary') {
    statusBadge.textContent = text;
    statusBadge.className = `badge bg-${variant} px-3 py-2 fs-6`;
  }

  async function fetchVault() {
    try {
      const resp = await fetch(`/api/vault/${slug}`, { cache: 'no-store' });
      if (!resp.ok) {
        const payload = await resp.json().catch(() => ({}));
        const code = resp.status === 410 ? '{{ _("This secret has burned.") }}' : '{{ _("Secret not found.") }}';
        showAlert(payload.error || code, resp.status === 410 ? 'warning' : 'danger');
        updateStatus('{{ _("Unavailable") }}', 'secondary');
        decryptBtn.disabled = true;
        return;
      }
      entry = await resp.json();
      renderMetadata(entry);
      updateStatus('{{ _("Ready to decrypt") }}', 'success');
      showAlert('{{ _("Secret ready. Paste the key and press decrypt.") }}', 'info');
    } catch (err) {
      console.error(err);
      showAlert('{{ _("Unable to load this secret. It may have burned.") }}', 'danger');
      updateStatus('{{ _("Offline") }}', 'secondary');
      decryptBtn.disabled = true;
    }
  }

  async function handleDecrypt() {
    const key = (keyInput.value || '').trim();
    if (!key) {
      showAlert('{{ _("Add the secret key first.") }}', 'warning');
      return;
    }
    try {
      const text = await decryptPayload(decodeURIComponent(key));
      if ((entry.payload_type || 'text') === 'file') {
        contentEl.textContent = '{{ _("Binary file ready to download below.") }}';
        prepareFileDownload(text);
      } else {
        clearFilePreview();
        contentEl.textContent = text;
      }
      updateStatus('{{ _("Unlocked") }}', 'success');
      showAlert('{{ _("Keep this window open only as long as you need.") }}', 'info');
    } catch (err) {
      console.error(err);
      showAlert('{{ _("Unable to decrypt. Check the secret key and try again.") }}', 'danger');
    }
  }

  autoKeyBtn.addEventListener('click', () => {
    const hash = window.location.hash.replace('#', '');
    if (hash) {
      keyInput.value = decodeURIComponent(hash);
      showAlert('{{ _("Secret key auto-filled from the link.") }}', 'success');
    } else {
      showAlert('{{ _("This link does not include the secret key fragment.") }}', 'warning');
    }
  });

  decryptBtn.addEventListener('click', handleDecrypt);
  clearBtn.addEventListener('click', () => {
    keyInput.value = '';
    contentEl.textContent = '';
    clearFilePreview();
    showAlert('{{ _("Key and decrypted message cleared.") }}', 'info');
    updateStatus('{{ _("Ready to decrypt") }}', 'success');
  });

  fetchVault();
  window.addEventListener('beforeunload', () => clearFilePreview());
})();
</script>
{% endblock %}
