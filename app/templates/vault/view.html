{% extends 'base.html' %}
{% block title %}Secure Vault{% endblock %}

{% block extra_css %}
<style>
html, body {
    min-height: 100%;
    height: auto;
    overflow-y: auto !important;
}

/* Κύρια διάταξη */
.vault-landing {
    display: block;
    padding: 2rem 0 7rem; /* extra χώρος κάτω */
}

.vault-card {
    max-width: 1000px;
    width: 100%;
    margin: 0 auto 3rem;  /* κενό πριν τον footer */
    border: none;
    backdrop-filter: blur(10px);
    background: rgba(255, 255, 255, 0.95);
}

/* αρκετό padding μέσα στην κάρτα, ώστε το τελευταίο κείμενο να μένει πάνω από τον footer */
.vault-card .card-body {
    padding: 2rem 2.5rem 6rem;
}

@media (max-width: 768px) {
    .vault-landing {
        padding: 1rem 0 5.5rem;
    }
    
    .vault-card {
        border-radius: 12px;
        margin: 0 0.5rem 2.5rem;
    }
    
    .vault-card .card-body {
        padding: 1.25rem 1.25rem 5rem;
    }
}

@media (max-width: 576px) {
    .vault-landing {
        padding: 0.5rem 0 5rem;
    }
    
    .input-group {
        flex-wrap: wrap;
    }
    
    .input-group .form-control {
        border-radius: 8px 8px 0 0 !important;
        width: 100%;
    }
    
    .input-group .btn {
        border-radius: 0 0 8px 8px !important;
        width: 100%;
        margin-top: -1px;
    }
    
    .d-flex.flex-column.flex-md-row {
        gap: 1rem !important;
    }
    
    .badge {
        align-self: flex-start;
    }
}

/* Secret / output styling */
.vault-output {
    margin-bottom: 3rem; /* buffer στο κάτω μέρος της κάρτας */
}

.vault-secret-value {
    white-space: pre-wrap;      /* κρατάει line breaks */
    word-wrap: break-word;
    max-width: 100%;
    overflow-x: visible;
    padding: 0;
    margin: 0;
    border: none;
    background: transparent;
    font-size: 1rem;
    line-height: 1.5;
    font-family: inherit;       /* ίδιο font με το υπόλοιπο */
    display: inline;            /* ίδια γραμμή με το label */
}

.vault-file {
    background: rgba(0, 0, 0, 0.03);
    border: 1px solid rgba(0, 0, 0, 0.1);
    border-radius: 10px;
    padding: 1rem;
    margin-top: 1rem;
}

.vault-file .d-flex {
    flex-wrap: wrap;
    gap: 0.75rem;
}

/* mobile βελτιώσεις */
@media (max-width: 768px) {
    .vault-file .d-flex {
        flex-direction: column;
    }
    
    .vault-file .btn {
        width: 100%;
        text-align: center;
    }
    
    .vault-key-section .form-label {
        font-size: 0.95rem;
        margin-bottom: 0.5rem;
    }
}

@media (max-width: 768px) {
    .btn {
        padding: 0.75rem 1rem;
        min-height: 48px;
    }
    
    .d-grid.gap-2 {
        gap: 0.75rem !important;
    }
}

/* Badge */
#vault-status-badge {
    font-size: 0.875rem;
    padding: 0.5rem 1rem;
    white-space: nowrap;
}

@media (max-width: 768px) {
    #vault-status-badge {
        align-self: flex-start;
        margin-top: 0.5rem;
    }
}

/* Alert */
#vault-alert .alert {
    border-radius: 8px;
    margin-bottom: 0;
}

/* Metadata */
#vault-metadata {
    font-size: 0.9rem;
    color: #6c757d;
    padding: 0.75rem;
    background: rgba(0, 0, 0, 0.03);
    border-radius: 8px;
    border-left: 4px solid #0d6efd;
}

/* File icon */
#vault-file-type-icon {
    font-size: 1.5rem;
    width: 40px;
    text-align: center;
}

@media (max-width: 576px) {
    #vault-file-type-icon {
        font-size: 1.25rem;
        width: 32px;
    }
}

/* container */
.container {
    max-width: 100%;
    padding-left: 1rem;
    padding-right: 1rem;
    overflow-x: hidden;
}

/* card body text wrapping */
.card-body {
    overflow-wrap: break-word;
    word-wrap: break-word;
}

/* input group */
.input-group {
    min-width: 0;
}

.form-control {
    min-width: 0;
}
</style>
{% endblock %}

{% block content %}
<section class="vault-landing" aria-labelledby="vault-landing-title">
  <div class="container">
    <div class="vault-card card card-glass shadow-lg mx-auto">
      <div class="card-body">
        <div class="d-flex flex-column flex-md-row align-items-start justify-content-between gap-3 mb-4">
          <div class="d-flex align-items-start gap-3 flex-grow-1">
            <i class="fa-solid fa-shield-halved fa-2x text-primary mt-1" aria-hidden="true"></i>
            <div class="flex-grow-1">
              <h3 id="vault-landing-title" class="mb-2">{{ _('Secure vault') }}</h3>
              <p class="text-muted mb-0">
                {{ _('This link delivers a one-time secret. Open it only from trusted devices; it burns after it is read or when it expires.') }}
              </p>
            </div>
          </div>
          <div class="d-flex flex-column align-items-start align-items-md-end mt-2 mt-md-0">
            <span class="badge bg-primary px-3 py-2 fs-6 mb-2" id="vault-status-badge">{{ _('Untouched') }}</span>
          </div>
        </div>
        
        <div class="mb-4" id="vault-alert" role="status" aria-live="polite"></div>
        
        <div class="mb-4 vault-key-section">
          <label class="form-label fw-semibold" for="vault-key">{{ _('Secret key (the part after the # in the link)') }}</label>
          <div class="input-group">
            <input type="text" class="form-control form-control-lg" id="vault-key" placeholder="{{ _('Paste or scan the link and include the secret') }}">
            <button class="btn btn-outline-primary" type="button" id="vault-auto-key">{{ _('Auto-fill from URL') }}</button>
          </div>
          <p class="text-muted small mt-2 mb-0">
            {{ _('Only the bearer of this secret key can decrypt the message. The server never stores it.') }}
          </p>
        </div>
        
        <div class="d-grid gap-3 mb-4">
          <button class="btn btn-primary btn-lg" type="button" id="vault-decrypt-btn">{{ _('Decrypt secret') }}</button>
          <button class="btn btn-outline-secondary" type="button" id="vault-clear-btn">{{ _('Clear key and message') }}</button>
        </div>
        
        <div class="mb-4" id="vault-metadata" tabindex="-1" aria-live="polite"></div>
        
        <div class="vault-output">
          <div class="mb-3">
            <span class="fw-semibold me-1">{{ _('Title') }}:</span>
            <span id="vault-title-placeholder" class="text-break"></span>
          </div>
          <div class="mb-2 d-none d-flex align-items-baseline flex-wrap" id="vault-secret-row">
            <span class="fw-semibold me-1">{{ _('Secret') }}:</span>
            <span id="vault-content" class="vault-secret-value"></span>
          </div>
          <div class="vault-file mt-3 d-none" id="vault-file-view">
            <div class="d-flex flex-column flex-md-row justify-content-between align-items-start gap-3">
              <div class="d-flex align-items-center gap-3 flex-grow-1">
                <i id="vault-file-type-icon" class="fa-solid fa-file fa-lg text-muted"></i>
                <div class="flex-grow-1">
                  <h6 class="mb-1" id="vault-file-name"></h6>
                  <p class="text-muted small mb-0" id="vault-file-meta"></p>
                </div>
              </div>
              <a class="btn btn-primary mt-2 mt-md-0 flex-shrink-0" id="vault-file-download" target="_blank" rel="noopener">{{ _('Download file') }}</a>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>
{% endblock %}

{% block scripts %}
{{ super() }}
<script>
(() => {
  const slug = "{{ slug }}";
  const statusBadge = document.getElementById('vault-status-badge');
  const alertEl = document.getElementById('vault-alert');
  const metadataEl = document.getElementById('vault-metadata');
  const titleEl = document.getElementById('vault-title-placeholder');
  const secretRow = document.getElementById('vault-secret-row');
  const contentEl = document.getElementById('vault-content');
  const fileView = document.getElementById('vault-file-view');
  const fileIconEl = document.getElementById('vault-file-type-icon');
  const fileNameEl = document.getElementById('vault-file-name');
  const fileMetaEl = document.getElementById('vault-file-meta');
  const fileDownloadEl = document.getElementById('vault-file-download');
  const DEFAULT_FILE_LABEL = '{{ _("Secret file") }}';
  const keyInput = document.getElementById('vault-key');
  const decryptBtn = document.getElementById('vault-decrypt-btn');
  const clearBtn = document.getElementById('vault-clear-btn');
  const autoKeyBtn = document.getElementById('vault-auto-key');

  const encoder = new TextEncoder();
  const decoder = new TextDecoder();
  let entry = null;
  let currentFileUrl = null;

  function showAlert(message, variant = 'info') {
    alertEl.innerHTML = `<div class="alert alert-${variant} alert-dismissible fade show mb-0" role="alert">
      ${message}
      <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
    </div>`;
  }

  function hexToBytes(value) {
    if (!value) return new Uint8Array();
    const matches = value.match(/.{1,2}/g) || [];
    return new Uint8Array(matches.map((chunk) => parseInt(chunk, 16)));
  }

  async function deriveVaultKey(secret) {
    const material = await window.crypto.subtle.importKey('raw', encoder.encode(secret), 'PBKDF2', false, ['deriveKey']);
    return window.crypto.subtle.deriveKey(
      {
        name: 'PBKDF2',
        salt: encoder.encode('hashwhisper-vault'),
        iterations: 100000,
        hash: 'SHA-256',
      },
      material,
      { name: 'AES-GCM', length: 256 },
      false,
      ['encrypt', 'decrypt']
    );
  }

  async function decryptPayload(secret) {
    if (!entry || !secret) {
      throw new Error('{{ _("Provide the secret key to decrypt the payload.") }}');
    }
    const key = await deriveVaultKey(secret);
    const iv = hexToBytes(entry.nonce);
    const tag = hexToBytes(entry.auth_tag);
    const cipher = hexToBytes(entry.ciphertext);
    const combined = new Uint8Array(cipher.length + tag.length);
    combined.set(cipher);
    combined.set(tag, cipher.length);
    const decrypted = await window.crypto.subtle.decrypt(
      { name: 'AES-GCM', iv, additionalData: encoder.encode('HashWhisper:v1') },
      key,
      combined
    );
    return decoder.decode(decrypted);
  }

  function renderMetadata(data) {
    const expires = data.expires_at ? new Date(data.expires_at).toLocaleString() : '{{ _("Never") }}';
    const views = data.views_remaining;
    const typeLabel = data.payload_type === 'file' ? '{{ _("File secret") }}' : '{{ _("Text secret") }}';
    metadataEl.innerHTML = `<div class="d-flex flex-wrap gap-3">
      <span><i class="fa-regular fa-clock me-1"></i> {{ _("Expires") }}: ${expires}</span>
      <span><i class="fa-regular fa-eye me-1"></i> {{ _("Views left") }}: ${views}</span>
      <span><i class="fa-regular fa-file me-1"></i> ${typeLabel}</span>
    </div>`;
    
    if (data.title) {
      titleEl.textContent = data.title;
    } else {
      titleEl.textContent = '';
    }
  }

  function formatReadableSize(bytes) {
    if (!Number.isFinite(bytes)) return '';
    if (bytes >= 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
    if (bytes >= 1024) return `${(bytes / 1024).toFixed(1)} KB`;
    return `${bytes} B`;
  }

  function getFileIconClass(mime) {
    if (!mime) return 'fa-file';
    if (mime.startsWith('image/')) return 'fa-file-image';
    if (mime.startsWith('audio/')) return 'fa-file-audio';
    if (mime.startsWith('video/')) return 'fa-file-video';
    if (mime === 'application/pdf') return 'fa-file-pdf';
    if (mime.includes('zip') || mime.includes('compressed')) return 'fa-file-zipper';
    if (mime.includes('wordprocessingml') || mime.includes('msword')) return 'fa-file-word';
    if (mime.includes('excel') || mime.includes('spreadsheetml')) return 'fa-file-excel';
    if (mime.includes('presentationml') || mime.includes('powerpoint')) return 'fa-file-powerpoint';
    if (mime.includes('json') || mime.includes('xml')) return 'fa-file-code';
    if (mime.startsWith('text/')) return 'fa-file-lines';
    return 'fa-file';
  }

  function clearFilePreview() {
    if (fileView) fileView.classList.add('d-none');
    if (currentFileUrl) {
      URL.revokeObjectURL(currentFileUrl);
      currentFileUrl = null;
    }
  }

  function base64ToBytes(value) {
    if (!value) return new Uint8Array();
    const raw = window.atob(value);
    const bytes = new Uint8Array(raw.length);
    for (let i = 0; i < raw.length; i += 1) {
      bytes[i] = raw.charCodeAt(i);
    }
    return bytes;
  }

  function prepareFileDownload(base64) {
    if (!entry || !fileView) return;
    const bytes = base64ToBytes(base64);
    const mime = entry.payload_mime || 'application/octet-stream';
    const blob = new Blob([bytes], { type: mime });
    if (currentFileUrl) {
      URL.revokeObjectURL(currentFileUrl);
    }
    currentFileUrl = URL.createObjectURL(blob);
    if (fileNameEl) {
      fileNameEl.textContent = entry.payload_name || DEFAULT_FILE_LABEL;
    }
    if (fileMetaEl) {
      fileMetaEl.textContent = `${mime} · ${formatReadableSize(entry.payload_size || bytes.length)}`;
    }
    if (fileDownloadEl) {
      fileDownloadEl.href = currentFileUrl;
      fileDownloadEl.download = entry.payload_name || 'secret-file';
    }
    if (fileIconEl) {
      const iconClass = getFileIconClass(mime);
      fileIconEl.className = `fa-solid ${iconClass} fa-lg text-muted`;
    }
    fileView.classList.remove('d-none');
  }

  function updateStatus(text, variant = 'primary') {
    statusBadge.textContent = text;
    statusBadge.className = `badge bg-${variant} px-3 py-2 fs-6`;
  }

  async function fetchVault() {
    try {
      const resp = await fetch(`/api/vault/${slug}`, { cache: 'no-store' });
      if (!resp.ok) {
        const payload = await resp.json().catch(() => ({}));
        const code = resp.status === 410 ? '{{ _("This secret has burned.") }}' : '{{ _("Secret not found.") }}';
        showAlert(payload.error || code, resp.status === 410 ? 'warning' : 'danger');
        updateStatus('{{ _("Unavailable") }}', 'secondary');
        decryptBtn.disabled = true;
        return;
      }
      entry = await resp.json();
      renderMetadata(entry);
      updateStatus('{{ _("Ready to decrypt") }}', 'success');
      showAlert('{{ _("Secret ready. Paste the key and press decrypt.") }}', 'info');
      
      const hash = window.location.hash.replace('#', '');
      if (hash) {
        keyInput.value = decodeURIComponent(hash);
      }
    } catch (err) {
      console.error(err);
      showAlert('{{ _("Unable to load this secret. It may have burned.") }}', 'danger');
      updateStatus('{{ _("Offline") }}', 'secondary');
      decryptBtn.disabled = true;
    }
  }

  async function handleDecrypt() {
    const key = (keyInput.value || '').trim();
    if (!key) {
      showAlert('{{ _("Add the secret key first.") }}', 'warning');
      keyInput.focus();
      return;
    }
    
    decryptBtn.disabled = true;
    decryptBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>{{ _("Decrypting...") }}';
    
    try {
      const text = await decryptPayload(decodeURIComponent(key));
      const type = (entry.payload_type || 'text');

      if (type === 'file') {
        if (secretRow) {
          secretRow.classList.add('d-none');
          contentEl.textContent = '';
        }
        prepareFileDownload(text);
      } else {
        clearFilePreview();
        contentEl.textContent = text;
        if (secretRow) {
          secretRow.classList.remove('d-none');
        }
      }

      updateStatus('{{ _("Unlocked") }}', 'success');
      showAlert('{{ _("Keep this window open only as long as you need.") }}', 'info');
    } catch (err) {
      console.error(err);
      showAlert('{{ _("Unable to decrypt. Check the secret key and try again.") }}', 'danger');
    } finally {
      decryptBtn.disabled = false;
      decryptBtn.textContent = '{{ _("Decrypt secret") }}';
    }
  }

  autoKeyBtn.addEventListener('click', () => {
    const hash = window.location.hash.replace('#', '');
    if (hash) {
      keyInput.value = decodeURIComponent(hash);
      showAlert('{{ _("Secret key auto-filled from the link.") }}', 'success');
    } else {
      showAlert('{{ _("This link does not include the secret key fragment.") }}', 'warning');
    }
  });

  decryptBtn.addEventListener('click', handleDecrypt);
  
  clearBtn.addEventListener('click', () => {
    keyInput.value = '';
    contentEl.textContent = '';
    if (secretRow) {
      secretRow.classList.add('d-none');
    }
    clearFilePreview();
    showAlert('{{ _("Key and decrypted message cleared.") }}', 'info');
    updateStatus('{{ _("Ready to decrypt") }}', 'success');
    keyInput.focus();
  });

  keyInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      handleDecrypt();
    }
  });

  fetchVault();
  window.addEventListener('beforeunload', () => clearFilePreview());
  
  function handleResize() {
    const body = document.querySelector('.vault-card .card-body');
    if (!body) return;
    if (window.innerWidth < 768) {
      body.classList.add('px-3');
    } else {
      body.classList.remove('px-3');
    }
  }
  
  window.addEventListener('resize', handleResize);
  handleResize();
})();
</script>
{% endblock %}
